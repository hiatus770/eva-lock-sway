-- DEPRECATED GRAPHICS.C FILE BEFORE REMOVING MANUAL TEXT RENDERING 

// Main render function of the program
void render(struct client_state *state){
    Viewport(0,0, state->width, state->height);
    glClearColor(0.0, 0.0, 0.0, 0.5);
    glClear(GL_COLOR_BUFFER_BIT);

    // TODO make this call all the entity's render function in the program!
    char *goal = "活動限界まで内部主エネルギー供給システムやめるスロー正常レース";
    // char *goal = "test";  // literally just the c character

    global_shader.use(&global_shader);

    vec3 model_translate = {-1.0f, -1.0f, 0.0f};
    mat4 model; glm_mat4_identity(model); glm_translate(model, model_translate);
    mat4 projection; glm_perspective(glm_rad(45.0f), 800.0f/600, 0.1f, 100.0f, projection);

    global_shader.set_mat4(&global_shader, "model", model);
    global_shader.set_mat4(&global_shader, "projection", *global_camera.get_projection_matrix(&global_camera));
    global_shader.set_mat4(&global_shader, "view", *global_camera.get_view_matrix(&global_camera));

    glBindVertexArray(VAO);
    glDrawArrays(GL_TRIANGLES, 0, 6);

    float color[] = {1.0, 0.5, 0.0};
    render_text(&text_shader, goal, -1.0, -0.25, 0.0005, color);

    render_font(&matisse, goal, 0.0, 0.0, 0.0005, color);

    // test_entity.render(&test_entity);

    eglSwapBuffers(state->egl_display, state->egl_surface);
}
/**
* This function is responsible for compiling and setting up shaders for their use in the render() function of the program, this is basically run for initializing opengl and all its quirks
* - make sure to have the egl context ready before calling this
* - make sure that all the file paths are correct when running this command as well
*/


/**
* This function handles getting the codepoints given a utf-8 encoded string for functionality later in the program
*/
uint32_t* utf8_to_codepoints(const char *s, size_t *out_len) {
    size_t cap = 16;
    size_t len = 0;
    uint32_t *codepoints = malloc(cap * sizeof *codepoints);
    if (!codepoints) return NULL;

    const unsigned char *p = (const unsigned char*)s;
    while (*p) {
        uint32_t cp;
        size_t nbytes;

        if (*p < 0x80) {
            // 1‑byte sequence: 0xxxxxxx
            cp = *p;
            nbytes = 1;
        }
        else if ((p[0] & 0xE0) == 0xC0) {
            // 2‑byte sequence: 110xxxxx 10xxxxxx
            cp = p[0] & 0x1F;
            nbytes = 2;
        }
        else if ((p[0] & 0xF0) == 0xE0) {
            // 3‑byte sequence: 1110xxxx 10xxxxxx 10xxxxxx
            cp = p[0] & 0x0F;
            nbytes = 3;
        }
        else if ((p[0] & 0xF8) == 0xF0) {
            // 4‑byte sequence: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
            cp = p[0] & 0x07;
            nbytes = 4;
        }
        else {
            // invalid leading byte
            free(codepoints);
            *out_len = 0;
            return NULL;
        }

        // Consume continuation bytes
        for (size_t i = 1; i < nbytes; ++i) {
            if ((p[i] & 0xC0) != 0x80) {
                // invalid continuation byte
                free(codepoints);
                *out_len = 0;
                return NULL;
            }
            cp = (cp << 6) | (p[i] & 0x3F);
        }

        // advance pointer
        p += nbytes;

        // append cp to array
        if (len + 1 > cap) {
            cap *= 2;
            uint32_t *tmp = realloc(codepoints, cap * sizeof *tmp);
            if (!tmp) {
                free(codepoints);
                *out_len = 0;
                return NULL;
            }
            codepoints = tmp;
        }
        codepoints[len++] = cp;
    }

    *out_len = len;
    return codepoints;
}

void init_freetype(){
    char *goal = "活動限界まで内部主エネルギー供給システムやめるスロー正常レース";

    init_font(&matisse, &text_shader, "/home/hiatus/Documents/waylandplaying/include/graphics/matias.otf", goal, 48, 1, 1);

    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    // This sets up the buffers for the text rendering
    glGenVertexArrays(1, &tVAO);
    glGenBuffers(1, &tVBO);
    glBindVertexArray(tVAO);
    glBindBuffer(GL_ARRAY_BUFFER, tVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(float) * 6 * 4, NULL, GL_DYNAMIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(float), 0);
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);

    log_debug("STARTING FREETYPE");
    init_table(&characters);

    FT_Library ft;
    if (FT_Init_FreeType(&ft)){
        log_error("ERROR::FREETYPE Could not init freetype library");
        return;
    }
    FT_Face face;
    if (FT_New_Face(ft, "/home/hiatus/Documents/waylandplaying/include/graphics/matias.otf", 0, &face)){
        log_error("ERROR:FREETYPE Failed to load the font");
        return;
    }
    log_debug("SETTING PIXEL FACES");
    FT_Set_Pixel_Sizes(face, 0, 48*3);

    log_debug("UNPACKING ALIGNMENT");
    glPixelStorei(GL_UNPACK_ALIGNMENT, 1); // disalbe byte-alignment restriction

    // Now we want to load all glyphs that are common + the ones in the strings that we want


    log_debug("STARTING MAIN CHAR LOOP");
    for (uint32_t c = 0; c < 128; c++){
        if (FT_Load_Char(face, c, FT_LOAD_RENDER)){
            log_error("FAILED TO LOAD GLYPH %c", c);
        }
        unsigned int texture;
        glGenTextures(1, &texture);
        glBindTexture(GL_TEXTURE_2D, texture);

        glTexImage2D(
            GL_TEXTURE_2D,
            0,
            GL_RED,
            face->glyph->bitmap.width,
            face->glyph->bitmap.rows,
            0,
            GL_RED,
            GL_UNSIGNED_BYTE,
            face->glyph->bitmap.buffer
        );

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        struct character character;
        character.TextureID = texture;
        vec2 temp = {face->glyph->bitmap.width, face->glyph->bitmap.rows};
        vec2 temp2 = {face->glyph->bitmap_left, face->glyph->bitmap_top};

        glm_vec2_copy(temp, character.size);
        glm_vec2_copy(temp2, character.bearing);
        character.advance = face->glyph->advance.x;

        table_set(&characters, c, character);
    }



    size_t n;
    uint32_t *codepoints = utf8_to_codepoints(goal, &n);
    for (size_t ind = 0; ind < n; ind++){
        uint32_t c = codepoints[ind];
        log_info("ADDING CHARACTER WITH CODE: %04X OR INT %d", c, c);

        if (FT_Load_Char(face, c, FT_LOAD_RENDER)){
            log_error("FAILED TO LOAD GLYPH %c", c);
        }
        unsigned int texture;
        glGenTextures(1, &texture);
        glBindTexture(GL_TEXTURE_2D, texture);

        glTexImage2D(
            GL_TEXTURE_2D,
            0,
            GL_RED,
            face->glyph->bitmap.width,
            face->glyph->bitmap.rows,
            0,
            GL_RED,
            GL_UNSIGNED_BYTE,
            face->glyph->bitmap.buffer
        );

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

        struct character character;
        character.TextureID = texture;
        vec2 temp = {face->glyph->bitmap.width, face->glyph->bitmap.rows};
        vec2 temp2= {face->glyph->bitmap_left, face->glyph->bitmap_top};
        character.advance = face->glyph->advance.x;

        glm_vec2_copy(temp, character.size);
        glm_vec2_copy(temp2, character.bearing);

        table_set(&characters, c, character);


    }

    print_table(&characters);
    FT_Done_Face(face);
    FT_Done_FreeType(ft);
}

void render_text(struct shader *shader, const char *s, float x, float y, float scale, vec3 color){
    shader->use(shader);
    glUniform3f(glGetUniformLocation(shader->ID, "text_color"), color[0], color[1], color[2]);
    glActiveTexture(GL_TEXTURE0);
    glBindVertexArray(tVAO);

    vec3 text_transform = {0.0, 0.0, 0.0};
    mat4 model; glm_mat4_identity(model); glm_translate(model, text_transform);

    text_shader.set_mat4(&text_shader, "model", model) ;
    text_shader.set_mat4(&text_shader, "projection", *global_camera.get_projection_matrix(&global_camera)) ;
    text_shader.set_mat4(&text_shader, "view", *global_camera.get_view_matrix(&global_camera));

    // Get all the code points
    size_t length;
    uint32_t* codepoints = utf8_to_codepoints(s, &length);
    assert(length != 0);

    for (size_t i = 0; i < length; i++){
        struct character ch;
        if (table_get(&characters, codepoints[i], &ch)){
            float xpos = x + ch.bearing[0] * scale;
            float ypos = y - (ch.size[1] - ch.bearing[1]) * scale;

            // Rendering triangle
            float w = ch.size[0] * scale;
            float h = ch.size[1] * scale;
            log_debug("CHARACTER %c X POS %f, Y POS %f", codepoints[i], xpos, ypos);
            log_debug("                 W %f,     H %f", w, h);
            // These are the two triangles needed to actually draw the texture
            float vertices[6][4] = {
                { xpos,     ypos + h,   0.0f, 0.0f },
                { xpos,     ypos,       0.0f, 1.0f },
                { xpos + w, ypos,       1.0f, 1.0f },
                { xpos,     ypos + h,   0.0f, 0.0f },
                { xpos + w, ypos,       1.0f, 1.0f },
                { xpos + w, ypos + h,   1.0f, 0.0f }
            };
            glBindTexture(GL_TEXTURE_2D, ch.TextureID);
            glBindBuffer(GL_ARRAY_BUFFER, tVBO);
            glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices);
            glBindBuffer(GL_ARRAY_BUFFER, 0);
            glDrawArrays(GL_TRIANGLES, 0, 6);

            x += (ch.advance >> 6) * scale; // bitshift by 6 to get value in pixels (2^6 = 64)
        }
    }
    glBindVertexArray(0);
    glBindTexture(GL_TEXTURE_2D, 0);
}

void initgl(struct client_state *state){

    init_freetype();

    glGenVertexArrays(1, &VAO);
    glBindVertexArray(VAO);

    glGenBuffers(1, &VBO);
    glBindBuffer(GL_ARRAY_BUFFER, VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(eva_gradient), eva_gradient, GL_STATIC_DRAW);

    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);
    glEnableVertexAttribArray(0);

    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3* sizeof(float)));
    glEnableVertexAttribArray(1);

    init_shader(&global_shader, "/shaders/vertex.vs", "/shaders/fragment.fs");
    init_shader(&text_shader, "/shaders/text_vertex.vs", "/shaders/text_fragment.fs");

    vec3 temp_position = {0.0f, 0.0f, 3.0f};
    init_camera(&global_camera, temp_position);
    global_camera.set_position(&global_camera, temp_position);

    init_entity(&test_entity, &global_camera, &global_shader, VERTICES_COLOR, eva_gradient2, sizeof(eva_gradient2), GL_TRIANGLES);
    mat4 temp_trans; glm_mat4_identity(temp_trans); glm_mat4_copy(temp_trans, test_entity.model); // just for testing for now we are going to make it in a different spot from the original

}

void create_window_egl(struct client_state *state, int32_t width, int32_t height){
    EGLint attributes[] = {
        EGL_RED_SIZE, 8, EGL_GREEN_SIZE, 8, EGL_BLUE_SIZE, 8, EGL_SURFACE_TYPE, EGL_WINDOW_BIT, EGL_NONE
    };

    EGLConfig config;
    EGLint num_config, major, minor;
    EGLBoolean ret;

    state->egl_display = eglGetDisplay(state->wl_display);
    ret = eglInitialize(state->egl_display, &major, &minor);
    assert(ret == EGL_TRUE);
    ret = eglBindAPI(EGL_OPENGL_API);
    assert(ret == EGL_TRUE);

    eglChooseConfig(state->egl_display, attributes, &config, 1, &num_config);
    state->egl_context = eglCreateContext(state->egl_display, config, EGL_NO_CONTEXT, NULL);

    state->egl_window = wl_egl_window_create(state->wl_surface, width, height);
    state->egl_surface = eglCreateWindowSurface(state->egl_display, config, state->egl_window, NULL);
    eglMakeCurrent(state->egl_display, state->egl_surface, state->egl_surface, state->egl_context);
}
